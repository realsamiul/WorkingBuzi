<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Venturi Space | Mission Control</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;600&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --black: 4, 4, 4;
            --body: 4, 4, 4;
            --text: 244, 244, 244;
            --white: 255, 255, 255;
            --orange: 255, 53, 9;
            --grey: 26, 26, 26;
            --ease: cubic-bezier(0.25, 0, 0.25, 1);
            --font-display: 'Barlow', sans-serif;
            --font-tech: 'Rajdhani', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: rgb(var(--body));
            color: rgb(var(--text));
            overflow-x: hidden;
            font-family: var(--font-display);
            -webkit-font-smoothing: antialiased;
            overflow-y: auto;
            height: 100%;
        }

        /* Preloader */
        .loader {
            position: fixed;
            inset: 0;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            background: rgb(var(--body));
        }

        .loader-fill {
            position: fixed;
            inset: 0;
            background: rgb(var(--body));
            transition: transform 1s var(--ease);
            transform-origin: top;
        }

        .loader-data {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            transition: opacity 0.5s var(--ease);
        }

        .loader.hidden {
            pointer-events: none;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s var(--ease), visibility 0.5s;
        }

        .loader.hidden .loader-fill { 
            transform: scaleY(0); 
        }
        .loader.hidden .loader-data { 
            opacity: 0; 
        }

        .loader-status {
            font-family: var(--font-tech);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 1.5em;
            overflow: hidden;
        }

        .loader-status span {
            display: block;
            transition: transform 0.5s var(--ease);
        }

        .loader-status.launching .loader-prepare { transform: translateY(-100%); }
        .loader-status.launching .loader-ready { transform: translateY(-100%); }

        .loader-countdown {
            display: flex;
            align-items: center;
            font-family: var(--font-tech);
            font-variant-numeric: tabular-nums;
        }

        .loader-bars {
            width: 3.9rem;
            margin-right: 1rem;
        }

        .loader-bars rect {
            fill: rgba(255, 255, 255, 0.5);
            animation: pulse 2s steps(3) infinite;
        }
        .loader-bars rect:nth-child(1) { animation-delay: 0.23s; }
        .loader-bars rect:nth-child(2) { animation-delay: 0.46s; }
        .loader-bars rect:nth-child(3) { animation-delay: 0.69s; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        /* Globe Container */
        #globe-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            opacity: 0;
            transition: opacity 2s var(--ease);
            pointer-events: none;
        }

        /* Overlay text for debugging */
        .debug-info {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            color: white;
            font-family: monospace;
            font-size: 12px;
            opacity: 0.7;
        }

        /* FPS counter */
        #fps {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            color: rgb(var(--orange));
            font-family: var(--font-tech);
            font-size: 14px;
        }
    </style>

    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    
    <!-- THREE.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Improved Earth textures -->
    <script src="https://unpkg.com/three-globe@2.31.0/dist/three-globe.min.js"></script>
</head>
<body>

    <!-- PRELOADER -->
    <div class="loader" id="loader">
        <div class="loader-fill"></div>
        <div class="loader-data">
            <svg class="asset loader-logo" width="200" height="40" viewBox="0 0 200 40" xmlns="http://www.w3.org/2000/svg">
                <path d="M10,10 L30,30 L50,10" fill="none" stroke="white" stroke-width="4"/>
                <text x="60" y="28" fill="white" font-family="Rajdhani" font-size="18" font-weight="600">VENTURI SPACE</text>
            </svg>
            
            <div class="loader-status" id="loaderStatus">
                <span class="loader-prepare">Ready for launch</span>
                <span class="loader-ready">Take-off</span>
            </div>
            
            <div class="loader-countdown">
                <svg class="asset loader-bars" width="39" height="10" viewBox="0 0 39 10" fill="none">
                    <rect opacity="0.2" width="1" height="10" x="38" fill="#D9D9D9"></rect>
                    <rect opacity="0.6" width="1" height="10" x="22" fill="#D9D9D9"></rect>
                    <rect opacity="0.3" width="2" height="10" x="26" fill="#D9D9D9"></rect>
                    <rect opacity="0.8" width="3" height="10" x="8" fill="#D9D9D9"></rect>
                    <rect opacity="0.1" width="4" height="10" x="34" fill="#D9D9D9"></rect>
                </svg>
                <span class="loader-time" id="loaderTime">00:10:00</span>
            </div>
        </div>
    </div>

    <!-- DEBUG INFO -->
    <div class="debug-info" id="debugInfo"></div>
    <div id="fps">FPS: 60</div>

    <!-- GLOBE CONTAINER -->
    <div id="globe-container"></div>

    <script>
        // Register GSAP plugins
        gsap.registerPlugin(ScrollTrigger);

        // --- PRELOADER ---
        const loaderEl = document.getElementById('loader');
        const loaderStatus = document.getElementById('loaderStatus');
        const loaderTime = document.getElementById('loaderTime');
        const debugInfo = document.getElementById('debugInfo');
        const fpsElement = document.getElementById('fps');
        
        let timeLeft = 3.0;
        
        const timerInterval = setInterval(() => {
            timeLeft -= 0.1;
            if (timeLeft <= 0) {
                timeLeft = 0;
                clearInterval(timerInterval);
                launchSequence();
            }
            const seconds = Math.floor(timeLeft);
            const ms = Math.floor((timeLeft % 1) * 100);
            loaderTime.textContent = `00:${seconds.toString().padStart(2, '0')}:${ms.toString().padStart(2, '0')}`;
        }, 100);

        function launchSequence() {
            loaderStatus.classList.add('launching');
            
            setTimeout(() => {
                loaderEl.classList.add('hidden');
                document.getElementById('globe-container').style.opacity = 1;
                initScene();
            }, 1000);
        }

        // --- MAIN SCENE SETUP ---
        let scene, camera, renderer, controls;
        let satelliteModel = null;
        let earthGlobe = null;
        let stars = null;
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        function initScene() {
            const container = document.getElementById('globe-container');
            
            // Create scene with proper dark space background
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 0, 1000); // Start far away
            
            // Create renderer with proper settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            container.appendChild(renderer.domElement);
            
            // Create orbit controls (for debugging, will be disabled for production)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false;
            controls.enableRotate = true;
            controls.autoRotate = false;
            controls.maxDistance = 2000;
            controls.minDistance = 100;

            // --- CREATE REALISTIC STARFIELD ---
            createStarfield();
            
            // --- LOAD SATELLITE FIRST ---
            loadSatellite();
            
            // --- CREATE EARTH (will be added later) ---
            createEarth();
            
            // --- LIGHTING SETUP ---
            setupLighting();
            
            // Start animation
            animate();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createStarfield() {
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                // Position stars in a sphere around the scene
                const radius = 3000 + Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Random sizes with some variation
                starSizes[i] = 0.5 + Math.random() * 2.5;
                
                // Slight color variation (mostly white with hints of blue/orange)
                const colorVariation = Math.random() * 0.3;
                starColors[i * 3] = 1.0 - colorVariation;
                starColors[i * 3 + 1] = 1.0 - colorVariation * 0.5;
                starColors[i * 3 + 2] = 1.0 - colorVariation;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 1.5,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function loadSatellite() {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                './assets/sentinel.glb',
                (gltf) => {
                    console.log('Satellite GLB loaded successfully');
                    
                    satelliteModel = gltf.scene;
                    
                    // Scale and position
                    satelliteModel.scale.set(10, 10, 10);
                    satelliteModel.position.set(200, 100, 300);
                    satelliteModel.rotation.set(0, Math.PI, 0);
                    
                    // Traverse and enhance materials
                    satelliteModel.traverse((child) => {
                        if (child.isMesh) {
                            // Enable shadows
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Enhance materials
                            if (child.material) {
                                // Make materials more metallic and reflective
                                child.material.metalness = 0.9;
                                child.material.roughness = 0.2;
                                child.material.envMapIntensity = 1.5;
                                
                                // Add emissive for glint effect
                                child.material.emissive = new THREE.Color(0x111111);
                                child.material.emissiveIntensity = 0.1;
                                
                                // Add subtle sheen
                                child.material.sheen = 0.5;
                                child.material.sheenRoughness = 0.3;
                                child.material.sheenColor = new THREE.Color(0xff3509);
                            }
                        }
                    });
                    
                    scene.add(satelliteModel);
                    debugInfo.textContent = 'Satellite loaded ✓';
                    
                    // Start camera animation around satellite
                    animateCameraToSatellite();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    debugInfo.textContent = `Loading satellite: ${percent}%`;
                },
                (error) => {
                    console.error('Error loading satellite GLB:', error);
                    debugInfo.textContent = 'Error loading satellite';
                    createFallbackSatellite();
                }
            );
        }

        function createFallbackSatellite() {
            console.log('Creating fallback satellite');
            
            const group = new THREE.Group();
            
            // Main body (gold/orange venturi color)
            const bodyGeometry = new THREE.BoxGeometry(8, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff5500,
                metalness: 0.95,
                roughness: 0.1,
                emissive: 0x222200,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            group.add(body);
            
            // Solar panels
            const panelGeometry = new THREE.BoxGeometry(40, 0.5, 30);
            const panelMaterial = new THREE.MeshStandardMaterial({
                color: 0x111133,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0x000022,
                emissiveIntensity: 0.1
            });
            
            const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            leftPanel.position.set(-25, 0, 0);
            leftPanel.castShadow = true;
            group.add(leftPanel);
            
            const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            rightPanel.position.set(25, 0, 0);
            rightPanel.castShadow = true;
            group.add(rightPanel);
            
            // Antenna dish
            const dishGeometry = new THREE.ConeGeometry(6, 10, 16);
            const dishMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 0.9,
                roughness: 0.1
            });
            const dish = new THREE.Mesh(dishGeometry, dishMaterial);
            dish.position.set(0, 12, 0);
            dish.rotation.x = Math.PI;
            dish.castShadow = true;
            group.add(dish);
            
            satelliteModel = group;
            satelliteModel.position.set(200, 100, 300);
            satelliteModel.rotation.set(0.3, 0.8, 0.2);
            scene.add(satelliteModel);
            
            debugInfo.textContent = 'Fallback satellite created ✓';
            
            // Start camera animation
            animateCameraToSatellite();
        }

        function createEarth() {
            // Create Earth with three-globe for better realism
            earthGlobe = Globe()
                .globeImageUrl('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
                .bumpImageUrl('https://unpkg.com/three-globe/example/img/earth-topology.png')
                .showAtmosphere(true)
                .atmosphereColor('rgba(100, 150, 255, 0.3)')
                .atmosphereAltitude(0.15)
                .globeMaterial(new THREE.MeshStandardMaterial({
                    roughness: 0.8,
                    metalness: 0.2,
                    bumpScale: 2
                }));
            
            // Get the Three.js objects from globe.gl
            const earthObject = earthGlobe;
            
            // Position Earth far away initially
            earthObject.position.set(-500, 0, -1000);
            earthObject.scale.set(150, 150, 150);
            
            // Enhance Earth materials
            earthObject.traverse((child) => {
                if (child.isMesh) {
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.envMapIntensity = 0.5;
                    }
                }
            });
            
            scene.add(earthObject);
            
            // Add a subtle rotation animation
            const earthRotation = { y: 0 };
            gsap.to(earthRotation, {
                y: Math.PI * 2,
                duration: 120,
                repeat: -1,
                ease: "none",
                onUpdate: () => {
                    earthObject.rotation.y = earthRotation.y;
                }
            });
            
            debugInfo.textContent += ' | Earth created ✓';
        }

        function setupLighting() {
            // Clear any existing lights
            scene.children.forEach(child => {
                if (child.isLight) {
                    scene.remove(child);
                }
            });
            
            // Main sun light (directional, simulating sunlight)
            const sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(500, 300, 500);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Fill light (ambient, very subtle)
            const fillLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(fillLight);
            
            // Back light for rim lighting
            const backLight = new THREE.DirectionalLight(0x4466ff, 0.5);
            backLight.position.set(-500, -200, -500);
            scene.add(backLight);
            
            // Venturi orange accent light (very subtle)
            const orangeLight = new THREE.PointLight(0xff3509, 0.8, 1000);
            orangeLight.position.set(300, 200, 400);
            scene.add(orangeLight);
            
            // Add lens flare effect for star glints
            const lensFlare = new THREE.PointLight(0xffffff, 0.5, 2000);
            lensFlare.position.set(-1000, 800, -1500);
            scene.add(lensFlare);
        }

        function animateCameraToSatellite() {
            if (!satelliteModel) return;
            
            // Camera animation sequence
            const tl = gsap.timeline();
            
            // Start: Camera far away, looking at satellite
            camera.position.set(0, 0, 1000);
            camera.lookAt(satelliteModel.position);
            
            // Sequence 1: Slow approach to satellite
            tl.to(camera.position, {
                x: 100,
                y: 50,
                z: 400,
                duration: 4,
                ease: "power2.inOut",
                onUpdate: () => {
                    camera.lookAt(satelliteModel.position);
                }
            })
            
            // Sequence 2: Orbit around satellite
            .to(camera.position, {
                x: -150,
                y: 80,
                z: 350,
                duration: 6,
                ease: "sine.inOut",
                onUpdate: () => {
                    camera.lookAt(satelliteModel.position);
                }
            })
            
            // Sequence 3: Pull back to reveal Earth
            .to(camera.position, {
                x: 0,
                y: 0,
                z: 800,
                duration: 5,
                ease: "power2.inOut",
                onUpdate: () => {
                    camera.lookAt(satelliteModel.position);
                },
                onComplete: () => {
                    // Now pan to Earth
                    animateCameraToEarth();
                }
            });
        }

        function animateCameraToEarth() {
            if (!earthGlobe) return;
            
            const tl = gsap.timeline();
            
            // Move camera to view both satellite and Earth
            tl.to(camera.position, {
                x: 300,
                y: 150,
                z: 600,
                duration: 5,
                ease: "power2.inOut",
                onUpdate: () => {
                    // Look between satellite and Earth
                    const lookAtPosition = new THREE.Vector3();
                    lookAtPosition.lerpVectors(
                        satelliteModel.position,
                        earthGlobe.position,
                        0.7
                    );
                    camera.lookAt(lookAtPosition);
                }
            })
            
            // Focus on Earth
            .to(camera.position, {
                x: 0,
                y: 0,
                z: 400,
                duration: 6,
                ease: "power2.inOut",
                onUpdate: () => {
                    camera.lookAt(earthGlobe.position);
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            frameCount++;
            
            // Update FPS counter every second
            if (deltaTime >= 1000) {
                fps = Math.round((frameCount * 1000) / deltaTime);
                fpsElement.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // Update controls
            if (controls) {
                controls.update();
            }
            
            // Animate satellite if it exists
            if (satelliteModel) {
                const time = performance.now() * 0.001;
                
                // Subtle floating animation
                satelliteModel.position.y += Math.sin(time * 0.5) * 0.05;
                
                // Slow rotation
                satelliteModel.rotation.y += 0.002;
                satelliteModel.rotation.x = Math.sin(time * 0.3) * 0.05;
                
                // Solar panel subtle movement
                satelliteModel.traverse((child) => {
                    if (child.name && child.name.includes('panel')) {
                        child.rotation.z = Math.sin(time * 0.2 + child.position.x * 0.01) * 0.02;
                    }
                });
                
                // Glint effect on metallic parts
                satelliteModel.traverse((child) => {
                    if (child.isMesh && child.material && child.material.emissive) {
                        const glint = Math.sin(time * 2 + child.position.x * 0.1) * 0.1 + 0.1;
                        child.material.emissiveIntensity = glint;
                    }
                });
            }
            
            // Animate stars (subtle twinkle)
            if (stars) {
                const time = performance.now() * 0.0005;
                stars.rotation.y += 0.0001;
                
                // Update star sizes for twinkling effect
                const sizes = stars.geometry.attributes.size;
                for (let i = 0; i < sizes.count; i++) {
                    const twinkle = Math.sin(time + i * 0.1) * 0.3 + 0.7;
                    sizes.array[i] = (0.5 + Math.random() * 2.5) * twinkle;
                }
                sizes.needsUpdate = true;
            }
            
            // Render
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle resize
        window.addEventListener('resize', onWindowResize);

    </script>
</body>
</html>
